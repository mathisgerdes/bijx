<p align="center">
    <img src="docs/source/_static/icons/bijx.svg" alt="bijx logo" height="100">
    <br>
    <em><b>bij</b>ection + ja<b>x</b> = /ˈbaɪdʒæks/</em>
</p>

# Bijections & normalizing flows with JAX/NNX

This library provides flexible tools for building normalizing flows and conducting research, with a focus on applications in physics. It is built to offer powerful, reusable building blocks rather than a simplified interface for common use cases.

The library is built around two fundamental mathematical objects:

- **Bijections**: Invertible transformations that track their effect on probability densities.
- **Distributions**: Probability distributions with methods for sampling and density evaluation.

## Distinct Features

Besides specific design choices and approaches taken that differ from other libraries, it contains and caters to applications in physics especially lattice field theory. As such, it includes:

- **Continuous Normalizing Flows**: CNFs are a core architectural primitive. The library provides flexible wrappers (`ContFlowDiffrax`, `ContFlowRK4`) to turn any custom, differentiable vector field into a bijection, easing prototyping of novel flow architectures.

- **Differentiable Lie Group Operations**: The `bijx.lie` module provides tools for automatic differentiation on Lie group manifolds (e.g., SU(N)) e.g. for applications in gauge theory.

- **Structure-Preserving ODE Solvers**: To build robust continuous flows on manifolds, `bijx` includes a differentiable implementation of Crouch-Grossmann integrators (`bijx.cg`) on matrix Lie groups. These specialized ODE solvers are designed to preserve the geometric structure of the manifold, keeping solutions on the group.

- **Symmetry-Preserving Architectures**: The library provides examples of bijections that are designed to respect the symmetries of the underlying problem. The `ConvCNF` bijection, for instance, uses symmetric convolutions to build a flow that is equivariant to the symmetries of a lattice.

- **Fourier-Space Operations**: The `bijx.fourier` module provides tools for performing operations in Fourier space, e.g. for applications in lattice field theory, including decomposition into an independent set of real degrees of freedom.

## Quickstart

Here is a minimal example of building and sampling from a simple normalizing flow. We transform samples from a base distribution (a standard normal) using a chain of bijections to produce samples from a new, transformed distribution.

```python
import jax
import jax.numpy as jnp
import bijx

# Define simple base distributions
prior = bijx.IndependentNormal(event_shape=(2,))

# Compose bijections (here a simple shift and scaling)
flow = bijx.Chain(
    bijx.Shift(jnp.array([5.0, -2.0])),
    bijx.Scaling(jnp.array([2.0, 0.5]))
)

# sample from the base distribution
rng = jax.random.PRNGKey(42)
x, lp_x = prior.sample(batch_shape=(5,), rng=rng)

# transform samples with bijection
y, lp_y = flow.forward(x, lp_x)

# these can also be generated by combining prior and flow into a new distribution
dist = bijx.Transformed(prior, flow)

y2, lp_y2 = dist.sample(batch_shape=(5,), rng=rng)

# exactly the same as we used the same random key
assert jnp.allclose(y, y2)
```

## Design Principles

- **Modularity**: Different parts of the library should be usable on their own. Expose as many expressive building blocks as possible.
- **Flexibility**: Prioritize flexibility, sometimes at the cost of adding more ways to break things.
- **Runtime Shape Inference**: Use a `batch + space + channels` convention and automatic vectorization for flexible data shape handling.

## Installation

```bash
pip install -e .
```

For development and testing, install as an editable package with all dependencies:

```bash
pip install -e ".[dev]"
```

To keep the codebase tidy, please install `pip install pre-commit` and run `pre-commit install` before committing changes.

## Documentation

To compile and open a local server for the documentation, run `make livehtml` in the `docs/` directory.

## Testing

Run the tests, including docstring examples:

```bash
# Run all tests including doctests
python -m pytest tests/ src/bijx/ --doctest-modules

# Run only doctests
python -m pytest src/bijx/ --doctest-modules -v

# Test specific module
python -m pytest src/bijx/utils.py --doctest-modules -v
```

## Module Layout

The library is organized into core mathematical tools, machine learning components, and specific applications.

```
bijx/
├── __init__.py           # Main package exports
├── utils.py              # General utilities
├── distributions.py      # Core Distribution classes
├── samplers.py           # Sampling helpers
├── solvers.py            # ODE solver implementations
│
├── bijections/           # All bijection-related code
│   ├── base.py           # Core Bijection, Chain, etc.
│   ├── continuous.py     # Continuous flow wrappers
│   ├── conv_cnf.py       # Convolutional CNF architecture
│   ├── coupling.py       # Coupling layers
│   └── ...
│
├── nn/                   # Neural network components (NNX)
│   ├── conv.py           # Symmetric convolutions
│   ├── embeddings.py     # Time and positional embeddings
│   └── features.py       # Reusable feature-mappers
│
├── fourier.py            # Tools for Fourier-space operations
├── lie.py                # General-purpose Lie group operations
├── cg/                   # Crouch-Grossmann ODE integrators
│
└── lattice/              # Application: Lattice Field Theory
    ├── scalar.py         # Action and observables for phi^4 theory
    └── gauge.py          # Gauge field symmetry operations
```
